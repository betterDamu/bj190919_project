<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>

    // this 是执行上下文所管理的!!!!


   /*
    this 执行于谁  得看函数调用位置上的调用形式
        独立调用( fn() ) ---> this指向window
        构造调用( new fn() ) ---> this指向构造出来的实例对象
        隐式调用( obj.fn() ) ---> this指向obj
        显示调用( fn.call(obj) fn.apply(obj) ) ---> this指向指定的对象obj

      this的难点:
        1. 隐式丢失
            如何解决隐式丢失?
                使用硬绑定:  fn.bind(obj)  参数:对象 返回值是一个硬绑定了this的函数
                            硬绑定返回的fn函数  this执行已经固定死了!! 不再看函数调用位置上的调用形式

        2. 所有回调函数的this指向 一定要查阅文档
            我们看不到回调函数 调用位置上的调用形式   所以 所有回调函数this的指向 一定要查阅文档

        3. 学完es6之后
            箭头函数的this指向 指向与其上一层执行上下文中的this

            箭头函数一定都是给 回调函数来定义的
    */

    // document.write("abc")

    //以隐式调用的形式 给一个变量进行赋值  最终对这个变量进行独立调用 : 隐式丢失
    /*var write = document.write.bind(document);
    write("abc")*/


    (function () {
        //this ---> {a:"a"}
        //this就是一個闭包 {this:{a:"a"}}
        setTimeout(()=>{
            console.log(this)
        })

    }).call({a:"a"})
</script>
</html>